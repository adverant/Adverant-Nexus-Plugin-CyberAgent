/**
 * Malware Sample Repository
 *
 * Database operations for malware samples
 */

import { BaseRepository } from './base.repository';
import { MalwareSample, AnalysisStatus, ThreatLevel, QueryOptions, PaginatedResponse } from '../../types';
import { logger } from '../../utils/logger';

/**
 * Malware Sample Repository
 */
export class MalwareSampleRepository extends BaseRepository<MalwareSample> {
  constructor() {
    super('malware_samples');
  }

  /**
   * Declare JSONB columns for malware_samples table
   *
   * From database.types.ts:
   * - yara_matches: string[] (JSON array of YARA rule names)
   * - iocs: Record<string, any> (JSON IOC data)
   * - analysis_results: Record<string, any> (JSON analysis data)
   * - tags: string[] (JSON array of tags)
   */
  protected getJsonbColumns(): string[] {
    return ['yara_matches', 'iocs', 'analysis_results', 'tags'];
  }

  /**
   * Find sample by hash (SHA256)
   */
  async findBySHA256(sha256: string): Promise<MalwareSample | null> {
    try {
      const result = await this.query<MalwareSample>(
        `SELECT * FROM ${this.tableName} WHERE sha256 = $1 LIMIT 1`,
        [sha256]
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error('Error finding sample by SHA256', {
        sha256,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Find sample by MD5
   */
  async findByMD5(md5: string): Promise<MalwareSample | null> {
    try {
      const result = await this.query<MalwareSample>(
        `SELECT * FROM ${this.tableName} WHERE md5 = $1 LIMIT 1`,
        [md5]
      );

      return result.rows[0] || null;
    } catch (error) {
      logger.error('Error finding sample by MD5', {
        md5,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Find samples by organization
   */
  async findByOrganization(
    orgId: string,
    options: QueryOptions = {}
  ): Promise<PaginatedResponse<MalwareSample>> {
    const { limit = 20, offset = 0 } = options;

    const [samples, total] = await Promise.all([
      this.findWhere('org_id = $1', [orgId], {
        ...options,
        orderBy: 'first_seen',
        orderDirection: 'DESC'
      }),
      this.count('org_id = $1', [orgId])
    ]);

    return {
      data: samples,
      pagination: this.buildPaginationMetadata(total, limit, offset)
    };
  }

  /**
   * Find samples by malware family
   */
  async findByFamily(
    orgId: string,
    malwareFamily: string,
    options: QueryOptions = {}
  ): Promise<MalwareSample[]> {
    return this.findWhere('org_id = $1 AND malware_family = $2', [orgId, malwareFamily], options);
  }

  /**
   * Find samples by threat level
   */
  async findByThreatLevel(
    orgId: string,
    threatLevel: ThreatLevel,
    options: QueryOptions = {}
  ): Promise<MalwareSample[]> {
    return this.findWhere('org_id = $1 AND threat_level = $2', [orgId, threatLevel], options);
  }

  /**
   * Find samples by analysis status
   */
  async findByAnalysisStatus(
    orgId: string,
    status: AnalysisStatus,
    options: QueryOptions = {}
  ): Promise<MalwareSample[]> {
    return this.findWhere('org_id = $1 AND analysis_status = $2', [orgId, status], options);
  }

  /**
   * Find pending analysis samples
   */
  async findPendingAnalysis(limit: number = 10): Promise<MalwareSample[]> {
    try {
      const query = `
        SELECT * FROM ${this.tableName}
        WHERE analysis_status = 'pending'
        ORDER BY first_seen ASC
        LIMIT $1
      `;

      const result = await this.query<MalwareSample>(query, [limit]);
      return result.rows;
    } catch (error) {
      logger.error('Error finding pending analysis samples', {
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Update analysis status
   */
  async updateAnalysisStatus(
    id: string,
    status: AnalysisStatus
  ): Promise<MalwareSample | null> {
    const updateData: Partial<MalwareSample> = { analysis_status: status };

    if (status === 'analyzing' || status === 'completed' || status === 'failed') {
      updateData.last_analyzed = new Date();
    }

    return this.update(id, updateData);
  }

  /**
   * Update analysis results
   */
  async updateAnalysisResults(
    id: string,
    results: {
      malware_family?: string;
      threat_level?: ThreatLevel;
      yara_matches?: string[];
      iocs?: Record<string, any>;
      analysis_results?: Record<string, any>;
      tags?: string[];
    }
  ): Promise<MalwareSample | null> {
    return this.update(id, {
      ...results,
      analysis_status: 'completed',
      last_analyzed: new Date()
    });
  }

  /**
   * Find samples with similar characteristics
   */
  async findSimilar(
    sha256: string,
    limit: number = 5
  ): Promise<MalwareSample[]> {
    try {
      // Get the original sample first
      const original = await this.findBySHA256(sha256);
      if (!original) return [];

      // Find samples with same malware family or threat level
      const query = `
        SELECT * FROM ${this.tableName}
        WHERE sha256 != $1
        AND (
          malware_family = $2
          OR threat_level = $3
          OR tags && $4
        )
        ORDER BY
          CASE
            WHEN malware_family = $2 THEN 1
            WHEN threat_level = $3 THEN 2
            ELSE 3
          END,
          first_seen DESC
        LIMIT $5
      `;

      const result = await this.query<MalwareSample>(query, [
        sha256,
        original.malware_family,
        original.threat_level,
        JSON.stringify(original.tags),
        limit
      ]);

      return result.rows;
    } catch (error) {
      logger.error('Error finding similar samples', {
        sha256,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Search samples by filename
   */
  async searchByFilename(
    orgId: string,
    filename: string,
    options: QueryOptions = {}
  ): Promise<MalwareSample[]> {
    return this.findWhere(
      'org_id = $1 AND file_name ILIKE $2',
      [orgId, `%${filename}%`],
      options
    );
  }

  /**
   * Get samples statistics by organization
   */
  async getStatsByOrganization(orgId: string): Promise<{
    total: number;
    by_threat_level: Record<ThreatLevel | 'unknown', number>;
    by_status: Record<AnalysisStatus, number>;
    total_size_bytes: number;
    unique_families: number;
  }> {
    try {
      const query = `
        SELECT
          COUNT(*) as total,
          COUNT(*) FILTER (WHERE threat_level = 'critical') as critical,
          COUNT(*) FILTER (WHERE threat_level = 'high') as high,
          COUNT(*) FILTER (WHERE threat_level = 'medium') as medium,
          COUNT(*) FILTER (WHERE threat_level = 'low') as low,
          COUNT(*) FILTER (WHERE threat_level = 'benign') as benign,
          COUNT(*) FILTER (WHERE threat_level IS NULL) as unknown,
          COUNT(*) FILTER (WHERE analysis_status = 'pending') as pending,
          COUNT(*) FILTER (WHERE analysis_status = 'analyzing') as analyzing,
          COUNT(*) FILTER (WHERE analysis_status = 'completed') as completed,
          COUNT(*) FILTER (WHERE analysis_status = 'failed') as failed,
          COALESCE(SUM(file_size), 0) as total_size_bytes,
          COUNT(DISTINCT malware_family) FILTER (WHERE malware_family IS NOT NULL) as unique_families
        FROM ${this.tableName}
        WHERE org_id = $1
      `;

      const result = await this.query<any>(query, [orgId]);
      const row = result.rows[0];

      return {
        total: parseInt(row.total, 10),
        by_threat_level: {
          critical: parseInt(row.critical, 10),
          high: parseInt(row.high, 10),
          medium: parseInt(row.medium, 10),
          low: parseInt(row.low, 10),
          benign: parseInt(row.benign, 10),
          unknown: parseInt(row.unknown, 10)
        },
        by_status: {
          pending: parseInt(row.pending, 10),
          analyzing: parseInt(row.analyzing, 10),
          completed: parseInt(row.completed, 10),
          failed: parseInt(row.failed, 10)
        },
        total_size_bytes: parseInt(row.total_size_bytes, 10),
        unique_families: parseInt(row.unique_families, 10)
      };
    } catch (error) {
      logger.error('Error getting malware statistics', {
        orgId,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }

  /**
   * Check if sample exists by hash
   */
  async existsByHash(sha256: string): Promise<boolean> {
    try {
      const result = await this.query<{ exists: boolean }>(
        'SELECT EXISTS(SELECT 1 FROM malware_samples WHERE sha256 = $1)',
        [sha256]
      );

      return result.rows[0].exists;
    } catch (error) {
      logger.error('Error checking sample existence', {
        sha256,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      throw error;
    }
  }
}
