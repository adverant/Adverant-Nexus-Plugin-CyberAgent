/**
 * Pentest Job Processor
 *
 * Processes penetration testing scan jobs with Nexus integration
 */

import { Job } from 'bullmq';
import { BaseJobProcessor } from './base.processor';
import { JobData } from '../queue-config';
import { getNexusIntegration } from '../../nexus';

/**
 * Pentest Processor
 */
export class PentestProcessor extends BaseJobProcessor {
  constructor() {
    super('pentest');
  }

  /**
   * Execute penetration test scan
   */
  protected async executeScan(job: Job<JobData>): Promise<any> {
    const { job_id, target, tools, config, sandbox_tier } = job.data;

    this.logger.info('Starting penetration test', {
      job_id,
      target,
      tools,
      sandbox_tier
    });

    const results: any[] = [];
    let completedTools = 0;

    // Phase 1: Reconnaissance (20% of progress)
    await this.updateProgress(job_id, 10, 'Starting reconnaissance...', 'reconnaissance');

    const reconTools = tools.filter(t =>
      ['nmap', 'masscan', 'shodan', 'censys', 'subfinder', 'amass'].includes(t)
    );

    for (const tool of reconTools) {
      try {
        const toolOutput = await this.executeTool(
          job_id,
          tool,
          target,
          {
            ports: config?.ports || '1-65535',
            aggressive: config?.aggressive_scan || false,
            timing: config?.timing || 'normal'
          },
          sandbox_tier
        );

        const findings = this.parseToolOutput(tool, toolOutput);
        results.push(...findings);

        // Store open ports/services
        for (const finding of findings) {
          if (finding.type === 'open_port') {
            await this.storeVulnerability(job_id, {
              severity: 'info',
              title: `Open Port: ${finding.port}/${finding.protocol}`,
              description: `Service: ${finding.service} (${finding.version})`,
              affected_target: target,
              evidence: finding
            });
          }
        }

        completedTools++;
        await this.updateProgress(
          job_id,
          10 + Math.floor((completedTools / tools.length) * 10),
          `Completed ${tool}`,
          'reconnaissance'
        );
      } catch (error) {
        this.logger.error('Reconnaissance tool failed', {
          job_id,
          tool,
          error: error instanceof Error ? error.message : 'Unknown'
        });
      }
    }

    // Phase 2: Vulnerability Scanning (40% of progress)
    await this.updateProgress(job_id, 30, 'Starting vulnerability scanning...', 'vulnerability_scan');

    const vulnTools = tools.filter(t =>
      ['nuclei', 'nikto', 'wapiti', 'sqlmap', 'xsstrike', 'commix'].includes(t)
    );

    for (const tool of vulnTools) {
      try {
        const toolOutput = await this.executeTool(
          job_id,
          tool,
          target,
          {
            threads: config?.threads || 10,
            severity: config?.min_severity || 'low'
          },
          sandbox_tier
        );

        const vulnerabilities = this.parseToolOutput(tool, toolOutput);

        // Store vulnerabilities
        for (const vuln of vulnerabilities) {
          await this.storeVulnerability(job_id, {
            severity: vuln.severity,
            title: vuln.title,
            description: vuln.description,
            affected_target: vuln.url || target,
            cvss_score: vuln.cvss_score,
            cve_id: vuln.cve_id,
            cwe_id: vuln.cwe_id,
            remediation: vuln.remediation,
            evidence: vuln
          });
        }

        results.push(...vulnerabilities);

        completedTools++;
        await this.updateProgress(
          job_id,
          30 + Math.floor((completedTools / tools.length) * 40),
          `Completed ${tool} - Found ${vulnerabilities.length} issues`,
          'vulnerability_scan'
        );
      } catch (error) {
        this.logger.error('Vulnerability scanning tool failed', {
          job_id,
          tool,
          error: error instanceof Error ? error.message : 'Unknown'
        });
      }
    }

    // Phase 3: Exploitation (20% of progress)
    await this.updateProgress(job_id, 70, 'Starting exploitation attempts...', 'exploitation');

    const exploitTools = tools.filter(t =>
      ['metasploit', 'beef', 'exploit_db'].includes(t)
    );

    for (const tool of exploitTools) {
      try {
        const toolOutput = await this.executeTool(
          job_id,
          tool,
          target,
          {
            safe_mode: config?.safe_mode !== false, // Default to safe
            timeout: config?.exploit_timeout || 60
          },
          sandbox_tier
        );

        const exploits = this.parseToolOutput(tool, toolOutput);
        results.push(...exploits);

        // Store successful exploits
        for (const exploit of exploits) {
          if (exploit.success) {
            await this.eventPublisher.publishExploitSuccess(job_id, {
              exploit_name: exploit.name,
              target: exploit.target || target,
              payload: exploit.payload
            });

            await this.storeVulnerability(job_id, {
              severity: 'critical',
              title: `Exploit Successful: ${exploit.name}`,
              description: exploit.description,
              affected_target: exploit.target || target,
              evidence: exploit
            });
          } else {
            await this.eventPublisher.publishExploitFailed(job_id, {
              exploit_name: exploit.name,
              target: exploit.target || target,
              error: exploit.error || 'Exploit failed'
            });
          }
        }

        completedTools++;
        await this.updateProgress(
          job_id,
          70 + Math.floor((completedTools / tools.length) * 20),
          `Completed ${tool}`,
          'exploitation'
        );
      } catch (error) {
        this.logger.error('Exploitation tool failed', {
          job_id,
          tool,
          error: error instanceof Error ? error.message : 'Unknown'
        });
      }
    }

    // Phase 4: Post-Exploitation & Reporting (10% of progress)
    await this.updateProgress(job_id, 90, 'Generating report...', 'reporting');

    // Generate summary
    const summary = {
      total_findings: results.length,
      by_severity: this.countBySeverity(results),
      open_ports: results.filter(r => r.type === 'open_port').length,
      vulnerabilities: results.filter(r => r.type === 'vulnerability').length,
      successful_exploits: results.filter(r => r.type === 'exploit' && r.success).length
    };

    // Phase 5: Nexus Integration - Comprehensive Analysis
    let nexusAnalysis = null;
    try {
      await this.updateProgress(job_id, 95, 'Performing Nexus integration analysis...', 'nexus_analysis');

      const nexusIntegration = getNexusIntegration();

      // Prepare scan data for Nexus
      const scanData = {
        scan_id: job_id,
        target,
        scan_type: 'pentest',
        vulnerabilities: results.filter(r => r.type === 'vulnerability'),
        iocs: {
          iocs: {
            ip: results.filter(r => r.type === 'ip_address').map(r => r.value),
            domain: results.filter(r => r.type === 'domain').map(r => r.value)
          }
        },
        network_activity: {
          source_ips: results.filter(r => r.type === 'open_port').map(r => r.host),
          destination_ips: [target],
          ports: results.filter(r => r.type === 'open_port').map(r => r.port),
          protocols: results.filter(r => r.type === 'open_port').map(r => r.protocol)
        },
        services: results.filter(r => r.type === 'open_port').map(r => ({
          port: r.port,
          protocol: r.protocol,
          service: r.service,
          version: r.version
        })),
        duration_seconds: Math.floor((Date.now() - job.processedOn!) / 1000)
      };

      // Comprehensive Nexus analysis
      nexusAnalysis = await nexusIntegration.analyzeCompleteScan(scanData);

      this.logger.info('Nexus analysis completed', {
        job_id,
        threat_level: nexusAnalysis.overall_threat_level,
        recommendations: nexusAnalysis.recommended_actions.length
      });
    } catch (error) {
      this.logger.error('Nexus integration failed', {
        job_id,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      // Continue without Nexus analysis - degraded mode
    }

    await this.updateProgress(job_id, 100, 'Scan completed', 'completed');

    return {
      success: true,
      results_count: results.length,
      summary,
      results,
      nexus_analysis: nexusAnalysis
    };
  }

  /**
   * Parse tool output
   */
  protected parseToolOutput(tool: string, output: any): any[] {
    // This would contain tool-specific parsing logic
    // For now, return mock data structure

    if (!output || !output.results) {
      return [];
    }

    switch (tool) {
      case 'nmap':
        return this.parseNmapOutput(output.results);

      case 'nuclei':
        return this.parseNucleiOutput(output.results);

      case 'nikto':
        return this.parseNiktoOutput(output.results);

      case 'sqlmap':
        return this.parseSQLMapOutput(output.results);

      default:
        // Generic parsing
        return output.results.map((r: any) => ({
          ...r,
          tool,
          timestamp: new Date().toISOString()
        }));
    }
  }

  /**
   * Parse Nmap output
   */
  private parseNmapOutput(results: any): any[] {
    return (results.hosts || []).flatMap((host: any) => {
      return (host.ports || []).map((port: any) => ({
        type: 'open_port',
        port: port.port,
        protocol: port.protocol,
        state: port.state,
        service: port.service?.name,
        version: port.service?.version,
        host: host.address
      }));
    });
  }

  /**
   * Parse Nuclei output
   */
  private parseNucleiOutput(results: any): any[] {
    return (results.vulnerabilities || []).map((vuln: any) => ({
      type: 'vulnerability',
      severity: vuln.severity || 'medium',
      title: vuln.info?.name || 'Unknown vulnerability',
      description: vuln.info?.description,
      url: vuln.matched_at,
      cve_id: vuln.info?.classification?.cve_id,
      cvss_score: vuln.info?.classification?.cvss_score,
      remediation: vuln.info?.remediation
    }));
  }

  /**
   * Parse Nikto output
   */
  private parseNiktoOutput(results: any): any[] {
    return (results.vulnerabilities || []).map((vuln: any) => ({
      type: 'vulnerability',
      severity: this.mapNiktoSeverity(vuln.OSVDB),
      title: vuln.msg,
      description: `OSVDB-${vuln.OSVDB}`,
      url: vuln.url,
      evidence: vuln
    }));
  }

  /**
   * Parse SQLMap output
   */
  private parseSQLMapOutput(results: any): any[] {
    if (!results.data || results.data.length === 0) {
      return [];
    }

    return results.data.map((finding: any) => ({
      type: 'vulnerability',
      severity: 'critical',
      title: `SQL Injection: ${finding.parameter}`,
      description: `Type: ${finding.type}, DBMS: ${finding.dbms}`,
      url: finding.url,
      cwe_id: 'CWE-89',
      cvss_score: 9.0,
      evidence: finding
    }));
  }

  /**
   * Map Nikto severity
   */
  private mapNiktoSeverity(osvdb: string): string {
    // Simple mapping based on OSVDB ID ranges
    const id = parseInt(osvdb, 10);
    if (id > 10000) return 'high';
    if (id > 5000) return 'medium';
    return 'low';
  }

  /**
   * Count findings by severity
   */
  private countBySeverity(results: any[]): Record<string, number> {
    const counts: Record<string, number> = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };

    for (const result of results) {
      const severity = result.severity || 'info';
      counts[severity] = (counts[severity] || 0) + 1;
    }

    return counts;
  }
}
