/**
 * Malware Analysis Job Processor
 *
 * Processes malware analysis scan jobs with Nexus integration.
 * Includes built-in static analysis that works without external sandbox.
 */

import { Job } from 'bullmq';
import { BaseJobProcessor } from './base.processor';
import { JobData } from '../queue-config';
import { getNexusIntegration } from '../../nexus';
import { getStaticAnalyzer, FileAnalysisResult } from '../../services/static-analyzer.service';
import {
  getDecompilationService,
  DecompilationResult,
  MaliciousLocation,
  YaraMatch
} from '../../services/decompilation.service';
import { getDetonationChamberClient } from '../../sandbox/detonation-chamber-client';
import * as fs from 'fs/promises';
import * as path from 'path';
import * as os from 'os';
import { createWriteStream } from 'fs';
import { pipeline } from 'stream/promises';

/**
 * Malware Processor with built-in fallback analysis
 */
export class MalwareProcessor extends BaseJobProcessor {
  private sandboxAvailable: boolean | null = null;
  private sandboxCheckTime: number = 0;
  private static readonly SANDBOX_CHECK_INTERVAL = 60000; // Re-check every 60s

  constructor() {
    super('malware');
  }

  /**
   * Check if external sandbox is available
   */
  private async checkSandboxAvailability(): Promise<boolean> {
    const now = Date.now();

    // Use cached result if recent
    if (this.sandboxAvailable !== null &&
        (now - this.sandboxCheckTime) < MalwareProcessor.SANDBOX_CHECK_INTERVAL) {
      return this.sandboxAvailable;
    }

    try {
      // Simple health check - try to reach sandbox
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 5000);

      const response = await fetch('http://nexus-sandbox:9080/health', {
        signal: controller.signal
      }).catch(() => null);

      clearTimeout(timeout);

      this.sandboxAvailable = response?.ok === true;
      this.sandboxCheckTime = now;

      this.logger.info('Sandbox availability check', {
        available: this.sandboxAvailable
      });

      return this.sandboxAvailable;
    } catch {
      this.sandboxAvailable = false;
      this.sandboxCheckTime = now;
      return false;
    }
  }

  /**
   * Download file from URL to temp directory
   */
  private async downloadFile(url: string, jobId: string): Promise<string> {
    this.logger.info('Downloading file from URL', {
      job_id: jobId,
      url
    });

    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), `malware-${jobId}-`));
    const filename = path.basename(new URL(url).pathname) || `sample-${jobId}`;
    const filePath = path.join(tempDir, filename);

    try {
      const response = await fetch(url, {
        signal: AbortSignal.timeout(60000) // 60 second timeout
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      if (!response.body) {
        throw new Error('No response body received');
      }

      const fileStream = createWriteStream(filePath);
      await pipeline(response.body as any, fileStream);

      const stats = await fs.stat(filePath);

      this.logger.info('File downloaded successfully', {
        job_id: jobId,
        file_path: filePath,
        size_bytes: stats.size
      });

      return filePath;
    } catch (error) {
      // Clean up on error
      try {
        await fs.rm(tempDir, { recursive: true, force: true });
      } catch {}

      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      this.logger.error('File download failed', {
        job_id: jobId,
        url,
        error: errorMessage
      });

      throw new Error(`Failed to download file from ${url}: ${errorMessage}`);
    }
  }

  /**
   * Check if target is a URL
   */
  private isUrl(target: string): boolean {
    try {
      const url = new URL(target);
      return url.protocol === 'http:' || url.protocol === 'https:';
    } catch {
      return false;
    }
  }

  /**
   * Run built-in static analysis (always available, no external dependencies)
   */
  private async runBuiltinAnalysis(
    jobId: string,
    targetPath: string
  ): Promise<{ results: any[]; analysis: FileAnalysisResult | null }> {
    const results: any[] = [];
    let analysis: FileAnalysisResult | null = null;

    try {
      const analyzer = getStaticAnalyzer();
      analysis = await analyzer.analyzeFile(targetPath);

      // Convert built-in analysis to standard result format
      // Structure: file.*, detection.*, analysis.*
      // DetectedFileType: { mime, extension, description, category }
      // EntropyAnalysis: { overall, sections, isPacked, isEncrypted }
      // StringAnalysis: { totalStrings, suspiciousStrings, urls, ips, emails, registryKeys, filePaths }
      // PatternMatch: { rule, description, severity, offset?, matched? }
      // HeaderAnalysis: { type, architecture?, timestamp?, sections?, imports?, exports? }

      // File type detection result
      results.push({
        tool: 'builtin_filetype',
        type: 'file_info',
        file_type: analysis.detection.fileType,
        mime_type: analysis.detection.fileType.mime,
        extension: analysis.detection.fileType.extension,
        description: analysis.detection.fileType.description,
        category: analysis.detection.fileType.category,
        timestamp: new Date().toISOString()
      });

      // Hash results
      results.push({
        tool: 'builtin_hash',
        type: 'hash',
        md5: analysis.file.hashes.md5,
        sha1: analysis.file.hashes.sha1,
        sha256: analysis.file.hashes.sha256,
        file_size: analysis.file.size,
        timestamp: new Date().toISOString()
      });

      // Entropy analysis (high entropy = potentially packed/encrypted)
      if (analysis.analysis.entropy.isPacked || analysis.analysis.entropy.isEncrypted) {
        results.push({
          tool: 'builtin_entropy',
          type: 'indicator',
          is_suspicious: true,
          entropy: analysis.analysis.entropy.overall,
          is_encrypted: analysis.analysis.entropy.isEncrypted,
          is_packed: analysis.analysis.entropy.isPacked,
          high_entropy_regions: analysis.analysis.entropy.sections?.filter(s => s.entropy > 7.5).length || 0,
          timestamp: new Date().toISOString()
        });
      }

      // Pattern matches (YARA-like rules)
      for (const match of analysis.analysis.patterns) {
        results.push({
          tool: 'builtin_patterns',
          type: 'indicator',
          yara_match: true,
          rule_name: match.rule,
          is_malicious: match.severity === 'critical' || match.severity === 'high',
          threat_level: match.severity,
          matched_content: match.matched,
          offset: match.offset,
          description: match.description,
          timestamp: new Date().toISOString()
        });
      }

      // Extracted IOCs from strings analysis
      const stringAnalysis = analysis.analysis.strings;

      // URLs
      for (const url of stringAnalysis.urls) {
        results.push({
          tool: 'builtin_ioc',
          type: 'ioc',
          ioc_type: 'url',
          value: url,
          confidence: 0.8,
          timestamp: new Date().toISOString()
        });
      }

      // IPs
      for (const ip of stringAnalysis.ips) {
        results.push({
          tool: 'builtin_ioc',
          type: 'ioc',
          ioc_type: 'ip',
          value: ip,
          confidence: 0.8,
          timestamp: new Date().toISOString()
        });
      }

      // Emails
      for (const email of stringAnalysis.emails) {
        results.push({
          tool: 'builtin_ioc',
          type: 'ioc',
          ioc_type: 'email',
          value: email,
          confidence: 0.7,
          timestamp: new Date().toISOString()
        });
      }

      // Registry Keys
      for (const regKey of stringAnalysis.registryKeys) {
        results.push({
          tool: 'builtin_ioc',
          type: 'ioc',
          ioc_type: 'registry',
          value: regKey,
          confidence: 0.9,
          timestamp: new Date().toISOString()
        });
      }

      // File Paths
      for (const filePath of stringAnalysis.filePaths) {
        results.push({
          tool: 'builtin_ioc',
          type: 'ioc',
          ioc_type: 'filepath',
          value: filePath,
          confidence: 0.7,
          timestamp: new Date().toISOString()
        });
      }

      // Header analysis (PE/ELF)
      if (analysis.analysis.headers) {
        results.push({
          tool: 'builtin_headers',
          type: 'header_analysis',
          header_type: analysis.analysis.headers.type,
          architecture: analysis.analysis.headers.architecture,
          timestamp_compiled: analysis.analysis.headers.timestamp,
          sections: analysis.analysis.headers.sections,
          imports: analysis.analysis.headers.imports,
          exports: analysis.analysis.headers.exports,
          timestamp: new Date().toISOString()
        });
      }

      // Suspicious strings
      if (stringAnalysis.suspiciousStrings.length > 0) {
        results.push({
          tool: 'builtin_strings',
          type: 'strings',
          suspicious_count: stringAnalysis.suspiciousStrings.length,
          samples: stringAnalysis.suspiciousStrings.slice(0, 20).map(s => ({
            value: s.value,
            type: s.type,
            context: s.context
          })),
          timestamp: new Date().toISOString()
        });
      }

      // Overall threat assessment
      if (analysis.detection.isSuspicious) {
        results.push({
          tool: 'builtin_threat',
          type: 'threat_assessment',
          is_malicious: analysis.detection.threatLevel === 'critical' || analysis.detection.threatLevel === 'high',
          threat_level: analysis.detection.threatLevel,
          suspicion_reasons: analysis.detection.suspicionReasons,
          timestamp: new Date().toISOString()
        });
      }

      // Count total IOCs
      const iocCount = stringAnalysis.urls.length + stringAnalysis.ips.length +
        stringAnalysis.emails.length + stringAnalysis.registryKeys.length +
        stringAnalysis.filePaths.length;

      this.logger.info('Built-in analysis completed', {
        job_id: jobId,
        file_type: analysis.detection.fileType.description,
        threat_level: analysis.detection.threatLevel,
        pattern_matches: analysis.analysis.patterns.length,
        iocs_found: iocCount
      });

    } catch (error) {
      this.logger.error('Built-in analysis failed', {
        job_id: jobId,
        error: error instanceof Error ? error.message : 'Unknown'
      });
    }

    return { results, analysis };
  }

  /**
   * Execute malware analysis
   */
  protected async executeScan(job: Job<JobData>): Promise<any> {
    const { job_id, target, tools, config, sandbox_tier } = job.data;

    this.logger.info('Starting malware analysis', {
      job_id,
      sample: target,
      tools,
      sandbox_tier: sandbox_tier || 'tier3'
    });

    const results: any[] = [];
    let filePath = target;
    let downloadedFile = false;

    // Phase 0A: Download file if target is a URL
    if (this.isUrl(target)) {
      await this.updateProgress(job_id, 2, 'Downloading file from URL...', 'download');
      try {
        filePath = await this.downloadFile(target, job_id);
        downloadedFile = true;
        this.logger.info('File ready for analysis', {
          job_id,
          original_url: target,
          local_path: filePath
        });
      } catch (error) {
        this.logger.error('Failed to download file, analysis cannot proceed', {
          job_id,
          url: target,
          error: error instanceof Error ? error.message : 'Unknown'
        });
        throw error;
      }
    }

    // Phase 0B: Built-in Static Analysis (always runs first - 15% of progress)
    await this.updateProgress(job_id, 5, 'Running built-in static analysis...', 'builtin_analysis');

    const { results: builtinResults, analysis: builtinAnalysis } = await this.runBuiltinAnalysis(job_id, filePath);
    results.push(...builtinResults);

    await this.updateProgress(job_id, 15, 'Built-in analysis complete', 'builtin_analysis');

    // Check sandbox availability for external tools
    const sandboxAvailable = await this.checkSandboxAvailability();

    if (!sandboxAvailable) {
      this.logger.warn('External sandbox unavailable, using built-in analysis only', {
        job_id,
        builtin_findings: builtinResults.length
      });
    }

    // Phase 1: External Static Analysis (25% of progress) - only if sandbox available
    if (sandboxAvailable) {
      await this.updateProgress(job_id, 20, 'Starting external static analysis...', 'static_analysis');

      const staticTools = tools.filter(t =>
        ['yara', 'clamav', 'exiftool', 'strings', 'pefile', 'radare2'].includes(t)
      );

      for (const tool of staticTools) {
        try {
          const toolOutput = await this.executeTool(
            job_id,
            tool,
            target,
            {
              deep_scan: config?.deep_scan || false
            },
            sandbox_tier || 'tier3'
          );

          const findings = this.parseToolOutput(tool, toolOutput);
          results.push(...findings);

          await this.updateProgress(
            job_id,
            20 + (staticTools.indexOf(tool) + 1) * (20 / staticTools.length),
            `Completed ${tool}`,
            'static_analysis'
          );
        } catch (error) {
          this.logger.error('Static analysis tool failed', {
            job_id,
            tool,
            error: error instanceof Error ? error.message : 'Unknown'
          });
        }
      }
    } else {
      // Skip external static analysis - mark as complete
      await this.updateProgress(job_id, 40, 'External static analysis skipped (sandbox unavailable)', 'static_analysis');
    }

    // Phase 1.5: Decompilation Analysis (optional - based on feature flag and threat level)
    // Uses Radare2 for quick disassembly on all suspicious files
    // Uses Ghidra for deep decompilation on high/critical threats
    const enableDecompilation = config?.enable_decompilation !== false; // Default enabled
    const isExecutable = builtinAnalysis?.detection.fileType.category === 'executable';
    const isSuspicious = builtinAnalysis?.detection.isSuspicious;
    const threatLevel = builtinAnalysis?.detection.threatLevel;

    let decompilationResult: DecompilationResult | null = null;
    let maliciousLocations: MaliciousLocation[] = [];

    if (enableDecompilation && isExecutable && isSuspicious) {
      await this.updateProgress(job_id, 42, 'Starting decompilation analysis...', 'decompilation');

      try {
        const decompilationService = getDecompilationService();

        // Determine decompilation depth based on threat level
        const useGhidra = threatLevel === 'high' || threatLevel === 'critical';

        this.logger.info('Starting decompilation phase', {
          job_id,
          file_path: filePath,
          depth: useGhidra ? 'deep (Ghidra)' : 'quick (Radare2)',
          threat_level: threatLevel
        });

        // Run decompilation
        decompilationResult = await decompilationService.decompileBinary(filePath, {
          depth: useGhidra ? 'deep' : 'quick',
          extractFunctions: true,
          extractStrings: true,
          extractXrefs: useGhidra, // Only for deep analysis
          maxFunctions: useGhidra ? 50 : 100,
          timeout: useGhidra ? 300 : 120
        });

        if (decompilationResult.success) {
          this.logger.info('Decompilation completed', {
            job_id,
            tool: decompilationResult.metadata.tool,
            functions_analyzed: decompilationResult.metadata.analyzedFunctions,
            total_functions: decompilationResult.metadata.totalFunctions,
            duration_ms: decompilationResult.metadata.duration_ms
          });

          // Correlate YARA matches from static analysis to functions
          const yaraMatches: YaraMatch[] = results
            .filter(r => r.yara_match || r.tool === 'builtin_patterns')
            .map(r => ({
              rule: r.rule_name || r.rule || r.name,
              description: r.description,
              severity: r.threat_level || r.severity,
              offset: r.offset,
              matched: r.matched_content || r.matched
            }));

          if (yaraMatches.length > 0) {
            maliciousLocations = decompilationService.correlateYaraToFunctions(
              decompilationResult.functions,
              yaraMatches
            );

            this.logger.info('YARA to function correlation completed', {
              job_id,
              yara_matches: yaraMatches.length,
              malicious_locations: maliciousLocations.length
            });
          }

          // Add decompilation results to findings
          results.push({
            tool: `decompilation_${decompilationResult.metadata.tool}`,
            type: 'decompilation',
            success: true,
            tool_used: decompilationResult.metadata.tool,
            tool_version: decompilationResult.metadata.toolVersion,
            functions_analyzed: decompilationResult.metadata.analyzedFunctions,
            total_functions: decompilationResult.metadata.totalFunctions,
            architecture: decompilationResult.metadata.architecture,
            format: decompilationResult.metadata.format,
            entry_point: decompilationResult.metadata.entryPoint,
            duration_ms: decompilationResult.metadata.duration_ms,
            timestamp: new Date().toISOString()
          });

          // Add malicious location findings
          for (const location of maliciousLocations) {
            results.push({
              tool: 'decompilation_correlation',
              type: 'malicious_location',
              indicator: location.indicator,
              description: location.description,
              severity: location.severity,
              address: location.address,
              function_name: location.functionName,
              function_address: location.functionAddress,
              matched_content: location.matchedContent,
              confidence: location.confidence,
              code_context: location.codeContext?.substring(0, 500),
              timestamp: new Date().toISOString()
            });

            // Publish malicious location event for high-severity findings
            if (location.severity === 'critical' || location.severity === 'high') {
              await this.eventPublisher.publishVulnerabilityFound(job_id, {
                severity: location.severity as any,
                title: `Malicious code at ${location.functionName || location.address}`,
                cve_id: undefined,
                cvss_score: location.severity === 'critical' ? 9.0 : 7.0,
                affected_target: filePath
              });
            }
          }

          // Add suspicious function indicators
          const suspiciousFunctions = decompilationResult.functions.filter(
            f => f.suspiciousIndicators && f.suspiciousIndicators.length > 0
          );

          for (const func of suspiciousFunctions) {
            results.push({
              tool: 'decompilation_suspicious',
              type: 'suspicious_function',
              function_name: func.name,
              function_address: func.address,
              function_size: func.size,
              indicators: func.suspiciousIndicators,
              callee_count: func.callees?.length || 0,
              string_refs_count: func.stringRefs?.length || 0,
              complexity: func.complexity,
              timestamp: new Date().toISOString()
            });
          }

          await this.updateProgress(job_id, 44, `Decompilation complete: ${decompilationResult.metadata.analyzedFunctions} functions analyzed`, 'decompilation');
        } else {
          this.logger.warn('Decompilation failed', {
            job_id,
            error: decompilationResult.error
          });

          results.push({
            tool: 'decompilation',
            type: 'decompilation',
            success: false,
            error: decompilationResult.error,
            timestamp: new Date().toISOString()
          });

          await this.updateProgress(job_id, 44, 'Decompilation failed - continuing analysis', 'decompilation');
        }
      } catch (decompError) {
        const errorMessage = decompError instanceof Error ? decompError.message : 'Unknown error';
        this.logger.error('Decompilation phase failed', {
          job_id,
          error: errorMessage
        });

        results.push({
          tool: 'decompilation',
          type: 'decompilation',
          success: false,
          error: errorMessage,
          timestamp: new Date().toISOString()
        });

        // Continue without decompilation - degraded mode
        await this.updateProgress(job_id, 44, 'Decompilation skipped due to error', 'decompilation');
      }
    } else if (enableDecompilation && isExecutable && !isSuspicious) {
      this.logger.debug('Skipping decompilation - file not suspicious', {
        job_id,
        is_executable: isExecutable,
        is_suspicious: isSuspicious
      });
      await this.updateProgress(job_id, 44, 'Decompilation skipped (file not suspicious)', 'decompilation');
    } else if (!isExecutable) {
      this.logger.debug('Skipping decompilation - not an executable', {
        job_id,
        file_category: builtinAnalysis?.detection.fileType.category
      });
      await this.updateProgress(job_id, 44, 'Decompilation skipped (not executable)', 'decompilation');
    } else {
      this.logger.debug('Decompilation disabled by configuration', { job_id });
      await this.updateProgress(job_id, 44, 'Decompilation disabled', 'decompilation');
    }

    // Phase 2: Dynamic Analysis (40% of progress) - only if sandbox available
    // ENHANCED: Enable network monitoring when file is suspicious
    const enableNetworkAnalysis = config?.enable_network_simulation ||
                                   builtinAnalysis?.detection.isSuspicious ||
                                   builtinAnalysis?.detection.threatLevel === 'high' ||
                                   builtinAnalysis?.detection.threatLevel === 'critical';

    if (sandboxAvailable) {
      await this.updateProgress(job_id, 45, 'Starting dynamic analysis...', 'dynamic_analysis');

      const dynamicTools = tools.filter(t =>
        ['cuckoo', 'anyrun', 'joe_sandbox', 'volatility', 'frida'].includes(t)
      );

      // Log if network analysis is being enabled
      if (enableNetworkAnalysis) {
        this.logger.info('Network monitoring enabled for dynamic analysis', {
          job_id,
          reason: config?.enable_network_simulation ? 'explicit_config' : 'suspicious_detection',
          threat_level: builtinAnalysis?.detection.threatLevel
        });
      }

      for (const tool of dynamicTools) {
        try {
          const toolOutput = await this.executeTool(
            job_id,
            tool,
            target,
            {
              timeout: config?.analysis_timeout || 600,
              // ENHANCED: Enable network when suspicious for C2 traffic analysis
              enable_network: enableNetworkAnalysis,
              vm_snapshot: config?.vm_snapshot,
              // ENHANCED: Always capture memory for forensic analysis
              capture_memory: true
            },
            'tier3' // Always use tier3 for dynamic analysis
          );

          const findings = this.parseToolOutput(tool, toolOutput);
          results.push(...findings);

          // Publish malware detected event
          if (findings.some(f => f.is_malicious)) {
            await this.eventPublisher.publishMalwareDetected(job_id, {
              sha256: target,
              malware_family: findings[0]?.malware_family,
              threat_level: findings[0]?.threat_level,
              yara_matches: findings.filter(f => f.yara_match).map(f => f.rule_name)
            });
          }

          // Extract and publish IOCs
          const iocs = findings.filter(f => f.type === 'ioc');
          for (const ioc of iocs) {
            await this.eventPublisher.publishIOCExtracted(job_id, {
              ioc_type: ioc.ioc_type,
              ioc_value: ioc.value,
              confidence: ioc.confidence
            });
          }

          await this.updateProgress(
            job_id,
            45 + (dynamicTools.indexOf(tool) + 1) * (40 / dynamicTools.length),
            `Completed ${tool}`,
            'dynamic_analysis'
          );
        } catch (error) {
          this.logger.error('Dynamic analysis tool failed', {
            job_id,
            tool,
            error: error instanceof Error ? error.message : 'Unknown'
          });
        }
      }
    } else {
      // Skip dynamic analysis - publish events from built-in results if malicious
      await this.updateProgress(job_id, 70, 'Dynamic analysis skipped (sandbox unavailable)', 'dynamic_analysis');

      // ENHANCED: Extract network IOCs from static analysis as fallback
      this.logger.info('Extracting network IOCs from static analysis (sandbox fallback mode)', {
        job_id,
        has_builtin_analysis: !!builtinAnalysis
      });

      if (builtinAnalysis) {
        const staticNetworkIOCs = this.extractStaticNetworkIOCs(builtinAnalysis);

        this.logger.info('Static network IOC extraction completed', {
          job_id,
          total_iocs: staticNetworkIOCs.length,
          ip_count: staticNetworkIOCs.filter(i => i.ioc_type === 'ip').length,
          url_count: staticNetworkIOCs.filter(i => i.ioc_type === 'url').length,
          domain_count: staticNetworkIOCs.filter(i => i.ioc_type === 'domain').length,
          c2_indicator_count: staticNetworkIOCs.filter(i => i.ioc_type === 'c2_indicator').length
        });

        // Add static network IOCs to results
        for (const ioc of staticNetworkIOCs) {
          results.push({
            tool: 'static_network_fallback',
            type: 'ioc',
            ioc_type: ioc.ioc_type,
            value: ioc.value,
            confidence: ioc.confidence,
            source: ioc.source,
            is_public_ip: ioc.is_public_ip,
            timestamp: new Date().toISOString()
          });

          // Publish each network IOC event
          await this.eventPublisher.publishIOCExtracted(job_id, {
            ioc_type: ioc.ioc_type,
            ioc_value: ioc.value,
            confidence: ioc.confidence
          });
        }

        await this.updateProgress(job_id, 80, `Extracted ${staticNetworkIOCs.length} network IOCs from static analysis`, 'static_network_fallback');
      }

      await this.updateProgress(job_id, 85, 'Static network IOC extraction complete', 'dynamic_analysis');

      // Publish malware detected event based on built-in analysis
      const maliciousFindings = results.filter(r => r.is_malicious);
      if (maliciousFindings.length > 0) {
        await this.eventPublisher.publishMalwareDetected(job_id, {
          sha256: builtinAnalysis?.file.hashes.sha256 || target,
          malware_family: maliciousFindings[0]?.malware_family,
          threat_level: builtinAnalysis?.detection.threatLevel || 'medium',
          yara_matches: results.filter(f => f.yara_match).map(f => f.rule_name)
        });
      }

      // Publish remaining IOCs from built-in analysis (non-network types)
      const iocs = results.filter(f => f.type === 'ioc' && f.tool !== 'static_network_fallback');
      for (const ioc of iocs) {
        await this.eventPublisher.publishIOCExtracted(job_id, {
          ioc_type: ioc.ioc_type,
          ioc_value: ioc.value,
          confidence: ioc.confidence
        });
      }
    }

    // Phase 2.5: Network Traffic & Reverse Engineering Analysis
    // Only run if network monitoring was enabled and sandbox was available
    if (sandboxAvailable && enableNetworkAnalysis) {
      await this.updateProgress(job_id, 86, 'Analyzing network traffic and extracting C2 indicators...', 'network_forensics');

      try {
        const detonationClient = getDetonationChamberClient();

        // Get comprehensive IOCs including network indicators from detonation chamber
        // This extracts C2 communications, DNS queries, HTTP requests captured during execution
        const analysisId = builtinAnalysis?.file.hashes.sha256 || target;

        this.logger.info('Extracting network IOCs from detonation chamber', {
          job_id,
          analysis_id: analysisId
        });

        // Note: In production, this would query the detonation chamber for the specific analysis
        // The IOCs are extracted from network traffic captured during sandbox execution

        // Add network-specific IOC types to results
        const networkIndicatorTypes = ['c2_ip', 'c2_domain', 'dns_query', 'http_callback', 'beacon_interval'];

        // Extract any network connections found in dynamic analysis results
        const networkFindings = results.filter(r =>
          r.tool === 'cuckoo' || r.tool === 'anyrun' || r.tool === 'joe_sandbox'
        );

        // Add network-specific findings
        for (const finding of networkFindings) {
          if (finding.network_connections) {
            for (const conn of finding.network_connections) {
              results.push({
                tool: 'network_forensics',
                type: 'ioc',
                ioc_type: 'c2_connection',
                value: `${conn.remote_address}:${conn.remote_port}`,
                protocol: conn.protocol,
                process: conn.process_name,
                confidence: 0.9,
                is_suspicious: true,
                timestamp: new Date().toISOString()
              });

              // Publish C2 IOC event
              await this.eventPublisher.publishIOCExtracted(job_id, {
                ioc_type: 'c2_connection',
                ioc_value: `${conn.remote_address}:${conn.remote_port}`,
                confidence: 0.9
              });
            }
          }

          // Extract DNS queries as IOCs
          if (finding.dns_queries) {
            for (const dns of finding.dns_queries) {
              results.push({
                tool: 'network_forensics',
                type: 'ioc',
                ioc_type: 'dns_query',
                value: dns.query,
                resolved_ips: dns.resolved_ips,
                confidence: 0.85,
                timestamp: new Date().toISOString()
              });
            }
          }

          // Extract HTTP callbacks as IOCs
          if (finding.http_requests) {
            for (const http of finding.http_requests) {
              results.push({
                tool: 'network_forensics',
                type: 'ioc',
                ioc_type: 'http_callback',
                value: http.url,
                method: http.method,
                user_agent: http.user_agent,
                confidence: 0.9,
                is_suspicious: true,
                timestamp: new Date().toISOString()
              });
            }
          }
        }

        // Log network analysis summary
        const networkIOCs = results.filter(r => r.tool === 'network_forensics');
        this.logger.info('Network forensics analysis completed', {
          job_id,
          c2_connections: networkIOCs.filter(r => r.ioc_type === 'c2_connection').length,
          dns_queries: networkIOCs.filter(r => r.ioc_type === 'dns_query').length,
          http_callbacks: networkIOCs.filter(r => r.ioc_type === 'http_callback').length
        });

      } catch (networkError) {
        this.logger.error('Network forensics analysis failed', {
          job_id,
          error: networkError instanceof Error ? networkError.message : 'Unknown'
        });
        // Continue without network analysis - degraded mode
      }
    }

    // Phase 3: Report Generation (10% of progress)
    await this.updateProgress(job_id, 90, 'Generating report...', 'reporting');

    const summary = {
      total_findings: results.length,
      is_malicious: results.some(r => r.is_malicious),
      malware_family: results.find(r => r.malware_family)?.malware_family,
      threat_level: this.determineThreatLevel(results),
      ioc_count: results.filter(r => r.type === 'ioc').length,
      yara_matches: results.filter(r => r.yara_match).length,
      sandbox_mode: sandboxAvailable ? 'full' : 'builtin_only',
      // Enhanced analysis indicators
      network_analysis_enabled: enableNetworkAnalysis,
      network_iocs: {
        c2_connections: results.filter(r => r.ioc_type === 'c2_connection').length,
        dns_queries: results.filter(r => r.ioc_type === 'dns_query').length,
        http_callbacks: results.filter(r => r.ioc_type === 'http_callback').length
      },
      reverse_engineering_enabled: tools.includes('radare2')
    };

    // Phase 4: Nexus Integration - Comprehensive Analysis
    let nexusAnalysis = null;
    try {
      await this.updateProgress(job_id, 95, 'Performing Nexus integration analysis...', 'nexus_analysis');

      const nexusIntegration = getNexusIntegration();

      // Prepare malware analysis data for Nexus (include built-in tools + network forensics)
      const malwareData = {
        analysis_id: job_id,
        sha256: builtinAnalysis?.file.hashes.sha256 || target,
        malware_family: summary.malware_family,
        threat_level: summary.threat_level,
        iocs: {
          iocs: {
            ip: results.filter(r => r.type === 'ioc' && r.ioc_type === 'ip').map(r => r.value),
            domain: results.filter(r => r.type === 'ioc' && r.ioc_type === 'domain').map(r => r.value),
            url: results.filter(r => r.type === 'ioc' && r.ioc_type === 'url').map(r => r.value),
            file_hash: results.filter(r => r.type === 'ioc' && r.ioc_type === 'hash').map(r => r.value),
            // Enhanced: C2 and network-related IOCs
            c2_connection: results.filter(r => r.type === 'ioc' && r.ioc_type === 'c2_connection').map(r => r.value),
            dns_query: results.filter(r => r.type === 'ioc' && r.ioc_type === 'dns_query').map(r => r.value),
            http_callback: results.filter(r => r.type === 'ioc' && r.ioc_type === 'http_callback').map(r => r.value)
          }
        },
        static_analysis: results.filter(r =>
          ['yara', 'clamav', 'pefile', 'strings', 'builtin_filetype', 'builtin_hash',
           'builtin_entropy', 'builtin_patterns', 'builtin_headers', 'builtin_strings', 'radare2'].includes(r.tool)
        ),
        behavioral_analysis: results.filter(r => ['cuckoo', 'anyrun', 'joe_sandbox'].includes(r.tool))[0],
        memory_analysis: results.filter(r => r.tool === 'volatility')[0],
        // Enhanced: Network forensics data
        network_forensics: results.filter(r => r.tool === 'network_forensics'),
        yara_matches: results.filter(r => r.yara_match)
      };

      // Comprehensive Nexus analysis
      nexusAnalysis = await nexusIntegration.analyzeCompleteMalware(malwareData);

      this.logger.info('Nexus analysis completed', {
        job_id,
        threat_score: nexusAnalysis.overall_threat_score,
        threat_actors: nexusAnalysis.attribution.threat_actors?.length || 0
      });
    } catch (error) {
      this.logger.error('Nexus integration failed', {
        job_id,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
      // Continue without Nexus analysis - degraded mode
    }

    await this.updateProgress(job_id, 100, 'Analysis completed', 'completed');

    // Cleanup: Delete downloaded file if we created it
    if (downloadedFile && filePath !== target) {
      try {
        const tempDir = path.dirname(filePath);
        await fs.rm(tempDir, { recursive: true, force: true });
        this.logger.info('Cleaned up downloaded file', {
          job_id,
          temp_dir: tempDir
        });
      } catch (cleanupError) {
        this.logger.warn('Failed to cleanup downloaded file', {
          job_id,
          file_path: filePath,
          error: cleanupError instanceof Error ? cleanupError.message : 'Unknown'
        });
      }
    }

    return {
      success: true,
      results_count: results.length,
      summary,
      results,
      nexus_analysis: nexusAnalysis,
      builtin_analysis: builtinAnalysis ? {
        file_type: builtinAnalysis.detection.fileType,
        hashes: builtinAnalysis.file.hashes,
        threat_level: builtinAnalysis.detection.threatLevel,
        is_suspicious: builtinAnalysis.detection.isSuspicious
      } : null
    };
  }

  /**
   * Parse tool output
   */
  protected parseToolOutput(tool: string, output: any): any[] {
    if (!output || !output.results) {
      return [];
    }

    // Tool-specific parsing would go here
    return output.results.map((r: any) => ({
      ...r,
      tool,
      timestamp: new Date().toISOString()
    }));
  }

  /**
   * Determine threat level from results
   */
  private determineThreatLevel(results: any[]): string {
    const maliciousCount = results.filter(r => r.is_malicious).length;
    const yaraMatches = results.filter(r => r.yara_match).length;

    if (maliciousCount > 5 || yaraMatches > 3) return 'critical';
    if (maliciousCount > 2 || yaraMatches > 1) return 'high';
    if (maliciousCount > 0 || yaraMatches > 0) return 'medium';
    return 'low';
  }

  /**
   * Static network IOC extraction result type
   */
  private static readonly C2_PATTERN_RULES = new Set([
    'CS_SLEEPTIME', 'CS_JITTER', 'CS_BEACON_DLL', 'CS_WATERMARK', 'CS_DIRECT',
    'CS_REFLECTIVE', 'CS_SPAWNTO', 'MSF_METERPRETER', 'MSF_METSRV', 'MSF_STDAPI',
    'MSF_REVERSE', 'MSF_BIND', 'MSF_TOOL', 'EMPIRE_INVOKE', 'EMPIRE_STAGER',
    'EMPIRE_DB', 'SLIVER_CLIENT', 'SLIVER_IMPLANT', 'BRC4_DIRECT', 'HAVOC_C2',
    'IP_PORT_COMBO', 'DDNS_C2', 'DGA_DOMAIN', 'DNS_TUNNEL', 'DNS_C2_TOOL',
    'DNS_ENCODED_DATA', 'PASTE_C2_RAW', 'PASTE_C2_SITE', 'GIST_C2', 'FILE_SHARE_C2',
    'DISCORD_C2', 'TELEGRAM_C2', 'SLACK_C2', 'HTTP_C2_ENDPOINT', 'C2_POLLING'
  ]);

  /**
   * Check if an IP address is private/internal (should be filtered from C2 IOCs)
   * @param ip - IPv4 address string
   * @returns true if the IP is private/reserved, false if public
   */
  private isPrivateIP(ip: string): boolean {
    const parts = ip.split('.').map(Number);

    // Validate IP format
    if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
      return true; // Invalid IPs treated as private (excluded)
    }

    const [a, b, c, d] = parts;

    // 10.0.0.0/8 - Private Class A
    if (a === 10) return true;

    // 172.16.0.0/12 - Private Class B
    if (a === 172 && b >= 16 && b <= 31) return true;

    // 192.168.0.0/16 - Private Class C
    if (a === 192 && b === 168) return true;

    // 127.0.0.0/8 - Loopback
    if (a === 127) return true;

    // 169.254.0.0/16 - Link-local
    if (a === 169 && b === 254) return true;

    // 0.0.0.0/8 - Current network
    if (a === 0) return true;

    // 224.0.0.0/4 - Multicast
    if (a >= 224 && a <= 239) return true;

    // 240.0.0.0/4 - Reserved
    if (a >= 240) return true;

    // 100.64.0.0/10 - Carrier-grade NAT
    if (a === 100 && b >= 64 && b <= 127) return true;

    // 192.0.0.0/24 - IETF Protocol Assignments
    if (a === 192 && b === 0 && c === 0) return true;

    // 192.0.2.0/24 - TEST-NET-1
    if (a === 192 && b === 0 && c === 2) return true;

    // 198.51.100.0/24 - TEST-NET-2
    if (a === 198 && b === 51 && c === 100) return true;

    // 203.0.113.0/24 - TEST-NET-3
    if (a === 203 && b === 0 && c === 113) return true;

    return false;
  }

  /**
   * Extract network IOCs from static analysis when sandbox is unavailable.
   * This provides a fallback mechanism for network indicator extraction
   * based on strings and patterns found during static analysis.
   *
   * @param analysis - FileAnalysisResult from built-in static analyzer
   * @returns Array of network IOCs with type, value, confidence, and source
   */
  private extractStaticNetworkIOCs(analysis: FileAnalysisResult): Array<{
    ioc_type: string;
    value: string;
    confidence: number;
    source: string;
    is_public_ip?: boolean;
  }> {
    const networkIOCs: Array<{
      ioc_type: string;
      value: string;
      confidence: number;
      source: string;
      is_public_ip?: boolean;
    }> = [];

    const seenValues = new Set<string>();

    // Helper to add IOC without duplicates
    const addIOC = (
      iocType: string,
      value: string,
      confidence: number,
      source: string,
      isPublicIp?: boolean
    ): void => {
      const key = `${iocType}:${value.toLowerCase()}`;
      if (!seenValues.has(key)) {
        seenValues.add(key);
        networkIOCs.push({
          ioc_type: iocType,
          value,
          confidence,
          source,
          is_public_ip: isPublicIp
        });
      }
    };

    // 1. Extract IPs from string analysis (filter private IPs)
    if (analysis.analysis.strings.ips) {
      for (const ip of analysis.analysis.strings.ips) {
        const isPublic = !this.isPrivateIP(ip);
        if (isPublic) {
          addIOC('ip', ip, 0.7, 'static_strings', true);
        }
      }
    }

    // 2. Extract URLs from string analysis
    if (analysis.analysis.strings.urls) {
      for (const url of analysis.analysis.strings.urls) {
        addIOC('url', url, 0.8, 'static_strings');

        // Also extract domain from URL
        try {
          const urlObj = new URL(url);
          const hostname = urlObj.hostname;
          // Skip if hostname is an IP address
          if (!/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/.test(hostname)) {
            addIOC('domain', hostname, 0.75, 'static_strings_url');
          }
        } catch {
          // Invalid URL, skip domain extraction
        }
      }
    }

    // 3. Extract domains from suspicious strings that match C2 patterns
    if (analysis.analysis.strings.suspiciousStrings) {
      for (const suspicious of analysis.analysis.strings.suspiciousStrings) {
        // Check for dynamic DNS domains
        const ddnsMatch = suspicious.value.match(
          /\b[A-Za-z0-9-]+\.(?:duckdns|no-ip|ddns|dynu|freedns)\.[a-z]+\b/gi
        );
        if (ddnsMatch) {
          for (const domain of ddnsMatch) {
            addIOC('domain', domain.toLowerCase(), 0.85, 'static_ddns_pattern');
          }
        }

        // Check for IP:Port combinations (potential C2)
        const ipPortMatch = suspicious.value.match(
          /\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}):(\d{1,5})\b/g
        );
        if (ipPortMatch) {
          for (const ipPort of ipPortMatch) {
            const [ip] = ipPort.split(':');
            if (!this.isPrivateIP(ip)) {
              addIOC('c2_indicator', ipPort, 0.9, 'static_ip_port', true);
            }
          }
        }

        // Check for paste sites (C2 staging)
        const pasteMatch = suspicious.value.match(
          /(?:pastebin\.com\/raw|hastebin\.com\/raw|paste\.ee\/r|ghostbin\.co|termbin\.com|dpaste\.org)\/[A-Za-z0-9]+/gi
        );
        if (pasteMatch) {
          for (const paste of pasteMatch) {
            addIOC('c2_staging', paste, 0.9, 'static_paste_site');
          }
        }

        // Check for messaging platform webhooks (C2 channels)
        const webhookMatch = suspicious.value.match(
          /discord(?:app)?\.com\/api\/webhooks\/[\d]+\/[A-Za-z0-9_-]+/gi
        );
        if (webhookMatch) {
          for (const webhook of webhookMatch) {
            addIOC('c2_channel', webhook, 0.95, 'static_discord_webhook');
          }
        }

        const telegramMatch = suspicious.value.match(
          /api\.telegram\.org\/bot[\w]+/gi
        );
        if (telegramMatch) {
          for (const telegram of telegramMatch) {
            addIOC('c2_channel', telegram, 0.95, 'static_telegram_bot');
          }
        }
      }
    }

    // 4. Extract C2 indicators from pattern matches
    if (analysis.analysis.patterns) {
      for (const pattern of analysis.analysis.patterns) {
        if (MalwareProcessor.C2_PATTERN_RULES.has(pattern.rule)) {
          // Extract any embedded IPs or domains from matched content
          if (pattern.matched) {
            // Check for IP addresses in matched content
            const ipMatches = pattern.matched.match(
              /\b(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\b/g
            );
            if (ipMatches) {
              for (const ip of ipMatches) {
                if (!this.isPrivateIP(ip)) {
                  addIOC('ip', ip, 0.85, `static_pattern_${pattern.rule}`, true);
                }
              }
            }

            // Check for domains in matched content
            const domainMatches = pattern.matched.match(
              /\b[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?(?:\.[A-Za-z0-9](?:[A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*\.[A-Za-z]{2,}\b/g
            );
            if (domainMatches) {
              for (const domain of domainMatches) {
                // Filter out common false positives
                if (!domain.match(/^(www|localhost|example)\./i) &&
                    !domain.match(/\.(dll|exe|sys|txt|log|ini)$/i)) {
                  addIOC('domain', domain.toLowerCase(), 0.8, `static_pattern_${pattern.rule}`);
                }
              }
            }
          }

          // Add the pattern rule itself as C2 indicator metadata
          addIOC('c2_indicator', pattern.rule, 0.9, 'static_pattern_match');
        }
      }
    }

    // 5. Extract domains from file paths that look like web paths
    if (analysis.analysis.strings.filePaths) {
      for (const filePath of analysis.analysis.strings.filePaths) {
        // Check for web-related paths that might contain domains
        if (filePath.includes('http') || filePath.includes('www')) {
          const urlMatch = filePath.match(/https?:\/\/[^\s"'<>]+/i);
          if (urlMatch) {
            addIOC('url', urlMatch[0], 0.7, 'static_filepath');
          }
        }
      }
    }

    // Sort by confidence (highest first) and limit to reasonable count
    return networkIOCs
      .sort((a, b) => b.confidence - a.confidence)
      .slice(0, 100);
  }
}
